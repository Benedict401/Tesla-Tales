/*
OneLoneCoder.com - Code-It-Yourself! Simple Tile Based Platform Game
"Its-a meee-a Jario!" - @Javidx9

License
~~~~~~~
Copyright (C) 2018  Javidx9
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions; See license for details.
Original works located at:
https://www.github.com/onelonecoder
https://www.onelonecoder.com
https://www.youtube.com/javidx9

GNU GPLv3
https://github.com/OneLoneCoder/videos/blob/master/LICENSE

From Javidx9 :)
~~~~~~~~~~~~~~~
Hello! Ultimately I don't care what you use this for. It's intended to be
educational, and perhaps to the oddly minded - a little bit of fun.
Please hack this, change it and use it in any way you see fit. You acknowledge
that I am not responsible for anything bad that happens as a result of
your actions. However this code is protected by GNU GPLv3, see the license in the
github repo. This means you must attribute me if you use it. You can view this
license here: https://github.com/OneLoneCoder/videos/blob/master/LICENSE
Cheers!


Background
~~~~~~~~~~
Tile maps are fundamental to most 2D games. This program explores emulating a classic 2D platformer
using floating point truncation to implement robust collision between a moving tile and a tilemap
representing the level.

Controls
~~~~~~~~
Left and Right arrow keys move Jario, Space bar jumps.
(Up and Down also move jario)

Author
~~~~~~
Twitter: @javidx9
Blog: www.onelonecoder.com
YouTube: www.youtube.com/javidx9
Discord: https://discord.gg/WhwHUMV

Video:
~~~~~~
https://youtu.be/oJvJZNyW_rw

Last Updated: 04/02/2018
*/
#define OLC_PGE_APPLICATION

#include <iostream>
#include <string>
#include <random>
//using namespace std;

#include "olcPixelGameEngine.h"
#include "RectangleCollisions.h"

#define OLC_PGEX_SOUND
#include "olcPGEX_Sound.h"
//#include "olcPGEX_AnimatedSprite.h"

class OneLoneCoder_Platformer : public olc::PixelGameEngine
{
public:
	OneLoneCoder_Platformer()
	{
		sAppName = "Tesla Tales";
	}

	/*
	//Sound
	static std::atomic<float> fFrequency;
	static std::atomic<float> fDutyCycle;
	static std::atomic<float> fHarmonics;

	static float SoundOut(int nChanel, float fGlobalTime, float fTimeStep)
	{
		//return sin(fGlobalTime * 440.0f * 2.0f * 3.14159f);
		return 0.5 * sampleSquareWave(fFrequency, fGlobalTime);
	}

	static float sampleSquareWave(float f, float t) {
		float a = 0;
		float b = 0;
		float p = fDutyCycle * 2.0f * 3.14159f;

		for (float n = 1; n < fHarmonics; n++) {
			float c = n * f * 2.0 * 3.14159f * t;
			a += sin(c) / n;
			b += sin(c - p * n) / n;
		}

		return (2.0 / 3.14159f) * (a - b);
	}
	*/

	olc::Sprite* sprWizard = nullptr;
	olc::Decal* decalWizard = nullptr;
	olc::Sprite* sprTiles = nullptr;
	olc::Decal* decalTiles = nullptr;
	olc::Sprite* sprEnemies = nullptr;
	olc::Decal* decalEnemies = nullptr;
	olc::Sprite* sprCleopatrasNeedle = nullptr;
	olc::Decal* decalCleopatrasNeedle = nullptr;

	std::string CurrentMap, Map1, Map2, Map3;

	struct bbTile {
	public:
		int TileID;
		olc::vi2d SpriteSheetPos;
	};

	struct bbRow {
		char cols[256];
	};

	struct bbLevelMap {
		bbRow bbRows[36];
	};
	
	enum KeyTypes { Empty = 0, DivE = 1, DivB = 2, CurlE = 3, CurlB = 4 };

	struct Key {
		int Type;
		olc::vf2d patchpos;
	};

	struct KeyPoint {
		olc::vf2d pos;
		Key HeldKey;
		//float CollectionClock = 0.0; // Or we could just press E
		//bool CollectionOpen = true;
	};

	struct LockPoint {
		olc::vf2d pos;
		Key CorrectKey;
		bool Open = false;
		olc::vf2d AnswerPatchPos;
		olc::vf2d AnswerPatchSize;
	};

	struct Player {
	public:
		olc::vf2d pos;
		olc::vf2d newPos;
		olc::vf2d vel;
		bool bJumping = false;
		bool bMovingRight = false;
		bool bMovingLeft = false;
		float MovementClock = 0.0;
		int AnimationSate = 0;
		bool bDead = false;
		int Lives = 3;
		Key HeldKey = { 0, {0,8} };
		bool StaffEnergised = false; 
	};

	struct EnemySegment {
	public:
		olc::vf2d pos;
		olc::vf2d vel;
		olc::vf2d patchpos;
		float MovementClock = 0.0;
		int AnimationState = 0;
		bool TopDeadly; //So we check all collisons, if there is a side collison player dead, if there is a non TopDeadly collison enemy dies
	};

	struct Enemy {
	public:

		int GetSoWhat() {
			return SoWhat;
		}
		//int Type;
		//olc::vf2d Origin;
		//float range;
		float LeftMostBound;
		float RightMostBound;
		std::vector<EnemySegment> Segments;
		//float MovementClock = 0.0;
		//int AnimationState = 0;
	private:
		int SoWhat = 7;
	};

	struct Camera {
		olc::vf2d pos = { 0.0f, 0.0f };
		olc::vf2d vel;
	};

	struct CameraMovement {
		olc::vf2d inipos;
		olc::vf2d vel;
		olc::vf2d finalpos;
		float EndPause;
		int Event = 0; //0 is no event.
	};

	struct CutScene {
		std::string Name;
		//olc::vf2d iniCamPos;
		std::vector<CameraMovement> CameraMovements;
		int CurrentStep = 0;
		int TotalSteps = 0;
		bool bPlayed = false;
		float Time = 0;
	};

	std::vector<CutScene> CutScenes;
	
	bbLevelMap CurrentLevelMap;
	int nCurrentLevel = 1;
	Player BrownWizard;
	std::vector<KeyPoint> KeyPoints;
	std::vector<LockPoint> LockPoints;
	std::vector<Enemy> Enemies;
	std::vector<Enemy> DeadEnemies;

	olc::vf2d TileOffset;
	int nLevelWidth = 256;
	int nLevelHeight = 36;
	//int nLevelWidth = 16;
	//int nLevelHeight = 16;
	int nTileWidth = 16;
	int nTileHeight = 16;
	int nVisibleTilesX = (ScreenWidth() / nTileWidth) + 1;
	int nVisibleTilesY = (ScreenHeight() / nTileHeight) +1;
	//olc::vf2d fCameraPos = { 0.0f, 0.0f };
	Camera bbCamera;
	bool bCollisionOccurred = false;
	//bool bKillerBlow = false;
	
	bool CleopatrasNeedleOn = false;
	float CleopatrasNeedleTime = 0;
	std::random_device rd1; // obtain a random number from hardware
	
	bool InCutScene = false;
	int noCutScene;

	bool InMenu = true;
	bool InMainMenu = true;
	int nMenuSelect = 0;

	std::vector<std::string> Licence;
	int numLines;

	bool bDemoFinished = false;

private:

protected:

	virtual bool OnUserCreate() override
	{
		//Sound eh? I hope this doesn't fuck everything up
		//olc::SOUND::InitialiseAudio(44100, 1, 8, 512);
		//olc::SOUND::SetUserSynthFunction(SoundOut);

		/*
		TestMap += "................";
		TestMap += "......11111.....";
		TestMap += ".....1..........";
		TestMap += ".....1..........";
		TestMap += ".........1......";
		TestMap += ".........1......";
		TestMap += ".......111......";
		TestMap += "................";
		TestMap += "................";
		TestMap += ".......11.1.....";
		TestMap += ".........1......";
		TestMap += "................";
		TestMap += "................";
		TestMap += "................";
		TestMap += "................";
		TestMap += "................";
		*/

		/*
		TestMap += "...1............................................................"; //0
		TestMap += "................................................................"; //1
		TestMap += "T..11..........................................................."; //2
		TestMap += "................................................................"; //3
		TestMap += "T..111.........................................................."; //4
		TestMap += "................................................................"; //5
		TestMap += "T..1111........................................................."; //6
		TestMap += "................................................................"; //7
		TestMap += "T..11111........................................................"; //8
		TestMap += "................................................................"; //9
		TestMap += "T..111111......................................................."; //10
		TestMap += "T..............................................................."; //11
		TestMap += "...1111111......................................................"; //12
		TestMap += "................................................................"; //13
		TestMap += "T..11111111....................................................."; //14
		TestMap += "T..............................................................."; //15
		TestMap += "T..1............................................................"; //16
		TestMap += "T..............................................................."; //17
		TestMap += "...11..........................................................."; //18
		TestMap += "................................................................"; //19
		TestMap += "...111.........................................................."; //20
		TestMap += "................................................................"; //21
		TestMap += "...1111........................................................."; //22
		TestMap += "................................................................"; //23
		TestMap += "...11111........................................................"; //24
		TestMap += ".....................................TTTTTTTTTTT................"; //25
		TestMap += "...111111......................................................."; //26
		TestMap += "..........................TTTTTTTTTTT.......1..................."; //27
		TestMap += "...1111111...............................1.....1................"; //28
		TestMap += ".............TTTTTTTTTTTTT.....................................1"; //29
		TestMap += "...11111111..........................1..1....1.................1"; //30
		TestMap += "..........................1111........1111111..................1"; //31
		TestMap += "...1.1.1.1.............1...........1...........1...............1"; //32
		TestMap += "......................111.........111.........11...............1"; //33
		TestMap += "1111111111111111111111111111111111111111111111111111111111111111"; //34
		TestMap += "1111111111111111111111111111111111111111111111111111111111111111"; //35
		*/


		// The Great Pyramid
		
		Map3 += "................................................................................................................................................................................................................................................................"; //0
		Map3 += "................................................................................................................................................................................................................................................................"; //1
		Map3 += "................................................................................................................................................................................................................................................................"; //2
		Map3 += "................................................................................................................................................................................................................................................................"; //3
		Map3 += "..............................................................................................................................111111............................................................................................................................"; //4
		Map3 += "..........................................................................................................................11111111111111........................................................................................................................"; //5
		Map3 += "......................................................................................................................1111111111111111111111...................................................................................................................."; //6
		Map3 += "..................................................................................................................111111111111111111111111111111................................................................................................................"; //7
		Map3 += "..............................................................................................................11111111111111111111111111111111111111............................................................................................................"; //8
		Map3 += "..........................................................................................................1111111111111111111111111111111111111111111111........................................................................................................"; //9
		Map3 += "......................................................................................................111111111111111111111111111111111111111111111111111111...................................................................................................."; //10
		Map3 += "..................................................................................................11111111111111111111111111111111111111111111111111111111111111................................................................................................"; //11
		Map3 += "..............................................................................................1111..............................................................1111............................................................................................"; //12
		Map3 += "..........................................................................................1111......................................................................1111........................................................................................"; //13
		Map3 += "......................................................................................1111..............................................................................1111...................................................................................."; //14
		Map3 += "..................................................................................1111......................................................................................1111................................................................................"; //15
		Map3 += "..............................................................................1111..............................................................................................1111............................................................................"; //16
		Map3 += "..........................................................................1111......................................................................................................1111........................................................................"; //17
		Map3 += "......................................................................1111..............................................................................................................1111...................................................................."; //18
		Map3 += "..................................................................1111......................................................................................................................1111................................................................"; //19
		Map3 += "..............................................................1111..............................................................................................................................1111............................................................"; //20
		Map3 += "..........................................................1111......................................................................................................................................1111........................................................"; //21
		Map3 += "......................................................1111..............................................................................................................................................1111...................................................."; //22
		Map3 += "..................................................1111......................................................................................................................................................1111................................................"; //23
		Map3 += "..............................................1111..............................................................................................................................................................1111............................................"; //24
		Map3 += "..........................................1111......................................................................................................................................................................1111........................................"; //25
		Map3 += "......................................1111..............................................................................................................................................................................1111...................................."; //26
		Map3 += "..................................1111......................................................................................................................................................................................1111................................"; //27
		Map3 += "..............................1111..............................................................................................................................................................................................1111............................"; //28
		Map3 += "..........................1111......................................................................................................................................................................................................1111........................"; //29
		Map3 += "......................1111..............................................................................................................................................................................................................1111...................."; //30
		Map3 += "..................1111111111................................................................................................................................................................................................................1111................"; //31
		Map3 += "..............11111111111.......................................................................................................................................................................................................................1111............"; //32
		Map3 += "..........111111111111.........................................................................................................................................................................................................................................."; //33
		Map3 += "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"; //34
		Map3 += "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"; //35


		// The Sphynx

		Map2 += "................................................................................................................................................................................................................................................................"; //0
		Map2 += "................................................................................................................................................................................................................................................................"; //1
		Map2 += "................................................................................................................................................................................................................................................................"; //2
		Map2 += "................................................................................................................................................................................................................................................................"; //3
		Map2 += "................................................................................................................................................................................................................................................................"; //4
		Map2 += "................................................................................................................................................................................................................................................................"; //5
		Map2 += "................................................................................................................................................................................................................................................................"; //6
		Map2 += "................................................................................................................................................................................................................................................................"; //7
		Map2 += "................................................................................................................................................................................................................................................................"; //8
		Map2 += "................................................................................................................................................................................................................................................................"; //9
		Map2 += "................................................................................................................................................................................................................................................................"; //10
		Map2 += "................................................................................................................................................................................................................................................................"; //11
		Map2 += "................................................................................................................................................................................................................................................................"; //12
		Map2 += "................................................................................................................................................................................................................................................................"; //13
		Map2 += "................................................................................................................................................................................................................................................................"; //14
		Map2 += "................................................................................................................................................................................................................................................................"; //15
		Map2 += "................................................................................................................................................................................................................................................................"; //16
		Map2 += "................................................................................................................................................................................................................................................................"; //17
		Map2 += "................................................................................................................................................................................................................................................................"; //18
		Map2 += "................................................................................................................................................................................................................................................................"; //19
		Map2 += "................................................................................................................................................................................................................................................................"; //20
		Map2 += "................................................................................................................................................................................................................................................................"; //21
		Map2 += "................................................................................................................................................................................................................................................................"; //22
		Map2 += "................................................................................................................................................................................................................................................................"; //23
		Map2 += "................................................................................................................................................................................................................................................................"; //24
		Map2 += "................................................................................................................................................................................................................................................................"; //25
		Map2 += "................................................................................................................................................................................................................................................................"; //26
		Map2 += "................................................................................................................................................................................................................................................................"; //27
		Map2 += "................................................................................................................................................................................................................................................................"; //28
		Map2 += "................................................................................................................................................................................................................................................................"; //29
		Map2 += "................................................................................................................................................................................................................................................................"; //30
		Map2 += "................................................................................................................................................................................................................................................................"; //31
		Map2 += "................................................................................................................................................................................................................................................................"; //32
		Map2 += "................................................................................................................................................................................................................................................................"; //33
		Map2 += "................................................................................................................................................................................................................................................................"; //34
		Map2 += "................................................................................................................................................................................................................................................................"; //35


		// Cleopatra's Needle

		Map1 += "................................................................................................................................................................................................................................................................"; //0
		Map1 += "................................................................................................................................................................................................................................................................"; //1
		Map1 += "................................................................................................................................................................................................................................................................"; //2
		Map1 += "................................................................................................................................................................................................................................................................"; //3
		Map1 += "................................................................................................................................................................................................................................................................"; //4
		Map1 += "................................................................................................................................................................................................................................................................"; //5
		Map1 += "...............................................................................................1111............................................................................................................................................................."; //6
		Map1 += "................................................................................................................................................................................................................................................................"; //7
		Map1 += "................................................................................................................................................................................................................................................................"; //8
		Map1 += "................................................................................................................................................................................................................................................................"; //9
		Map1 += ".........................................................................................1......................................................................................................................................................................"; //10
		Map1 += "........................................................................................111....................................................................................................................................................................."; //11
		Map1 += "........................................................................................111....................................................................................................................................................................."; //12
		Map1 += "........................................................................................111....................................................................................................................................................................."; //13
		Map1 += "........................................................................................111....................................................................................................................................................................."; //14
		Map1 += "........................................................................................111....................................................................................................................................................................."; //15
		Map1 += "........................................................................................111....................................................................................................................................................................."; //16
		Map1 += "........................................................................................111....................................................................................................................................................................."; //17
		Map1 += "........................................................................................111....................................................................................................................................................................."; //18
		Map1 += ".........................{..............................................................111....................................................................................................................................................................."; //19
		Map1 += "........................1111............................................................111....................................................................................................................................................................."; //20
		Map1 += "....................11..................................................................111....................................................................................................................................................................."; //21
		Map1 += ".................}...........................................................%..........111....................................................................................................................................................................."; //22
		Map1 += "...........[.....11........................................................1111.........111....................................................................................................................................................................."; //23
		Map1 += "..........111.............................2.............................$...............111....................................................................................................................................................................."; //24
		Map1 += "........]..........11.......11.........111111..........................1111..1111.......111..........................................................................1111......................................................................................."; //25
		Map1 += ".......111.........................5..........................£....3....................111...................................................................1111.............................................................................................."; //26
		Map1 += ".................11.....11.......1111....................1111111111111111111111111......111...............................................................................[......}.......{........]............................................................."; //27
		Map1 += "...........^.............................4..............................................111............................................................1111..............111HQWU1111KQWq1111JQWIO1111LQWASDF1111111111.........................................."; //28
		Map1 += "..........111......11.......11.........1111............................................11111.............................................................................111QQQu111111111111QQQio1111QQQasdf1111111111.........................................."; //29
		Map1 += "........&.........6......7.........!.............111ERWU1111TYWq1111erWIO1111tyWASDF1111111111...................................................1111....................111111111111111111111111111111111111111111111.........................................."; //30
		Map1 += ".......111.......11.....11.......1111............111QQQu111111111111QQQio1111QQQasdf1111111111...........................................................................111111111111111111111111111111111111111111111.........................................."; //31
		Map1 += ".................................................111111111111111111111111111111111111111111111.............................................1111..........................111111111111111111111111111111111111111111111.........................................."; //32
		Map1 += "....2..........3...........4.....................111111111111111111111111111111111111111111111......2........2.......3......3.....4.....4........5....5......^.....&.....111111111111111111111111111111111111111111111.........................................."; //33
		Map1 += "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"; //34
		Map1 += "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"; //35

		// Load Cut Scenes
		// Cleopatra's Needle
		CutScene CleopatrasNeedle;
		CleopatrasNeedle.Name = "CleopatrasNeedle";
		//CleopatrasNeedle.iniCamPos = { 52 * 16, 528 - (4 * 16) };
		CameraMovement CM;
		CM.inipos = { 52 * 16, 528 - (4 * 16) };
		CM.vel = { 80, 0 };
		CM.finalpos = { 89 * 16, 528 - (4 * 16) };
		CM.EndPause = 0;
		CleopatrasNeedle.CameraMovements.push_back(CM);
		CleopatrasNeedle.TotalSteps++;
		
		CM.inipos = { 89 * 16, 528 - (4 * 16) };
		CM.vel = { 0, -80 };
		CM.finalpos = { 89 * 16, 528 - (24 * 16) };
		CM.EndPause = 10; //Lets see how long that is - I think it is a second for 1
		CM.Event = 1; //Switch on Cleopatra's needle
		CleopatrasNeedle.CameraMovements.push_back(CM);
		CleopatrasNeedle.TotalSteps++;

		CM.inipos  = { 89 * 16, 528 - (24 * 16) };
		CM.vel = { 0, 0 };
		CM.finalpos = { 89 * 16, 528 - (24 * 16) };
		CM.EndPause = 10;
		CM.Event = 0; // Now if we have a 'wait' after each event...
		CleopatrasNeedle.CameraMovements.push_back(CM);
		CleopatrasNeedle.TotalSteps++;
		CutScenes.push_back(CleopatrasNeedle);
		//CameraMovement CM3;

		LoadCurrentLevel(nCurrentLevel, true); //Technically this is a 'start' but it counts as a restart 

		//TileOffset = { 36, 24 };

		//Wizard
		sprWizard = new olc::Sprite("BrownWizard.png");
		SpriteMaskingLoader({ 0,0 }, sprWizard, { 0,0 }, { 96,32 }, 1, 0);
		decalWizard = new olc::Decal(sprWizard, 1, 0);

		//Tiles 
		//sprTiles = new olc::Sprite("TeslaTalesTileSheetTiles.png");
		sprTiles = new olc::Sprite("EquationKeys.png");
		SpriteMaskingLoader({ 0,0 }, sprTiles, { 0,0 }, { 12 * 16, 10 * 16 }, 1, 0);
		decalTiles = new olc::Decal(sprTiles, 1, 0);

		//Enemies
		sprEnemies = new olc::Sprite("Bugs.png");
		SpriteMaskingLoader({ 0,0 }, sprEnemies, { 0,0 }, { 12 * 16, 4 * 16 }, 1, 0);
		decalEnemies = new olc::Decal(sprEnemies, 1, 0);

		//Cleopatra's Needle
		sprCleopatrasNeedle = new olc::Sprite("CleopatrasNeedle.png");
		SpriteMaskingLoader({ 0,0 }, sprCleopatrasNeedle, { 0,0 }, { 12 * 16, 8 * 16 }, 1, 0);
		decalCleopatrasNeedle = new olc::Decal(sprCleopatrasNeedle, 1, 0);

		std::cout << "Screen Width:" << ScreenWidth() << " ScreenHeight:" << ScreenHeight() << std::endl;


		return true;
	}
	
	bool OnUserDestroy() override{ //I hope this works
		olc::SOUND::DestroyAudio();
		return true;
	}

	virtual bool OnUserUpdate(float fElapsedTime) override
	{

		Clear(olc::BLACK);

		/*
		//Square wave controls
		if (GetKey(olc::Z).bHeld) fDutyCycle = fDutyCycle - 0.1f * fElapsedTime;
		if (GetKey(olc::X).bHeld) fDutyCycle = fDutyCycle + 0.1f * fElapsedTime;

		if (GetKey(olc::C).bHeld) if (fFrequency < 110) { fFrequency = fFrequency - 40 * fElapsedTime; } else { fFrequency = 110; };
		if (GetKey(olc::V).bHeld) fFrequency = fFrequency + 40 * fElapsedTime;

		if (GetKey(olc::B).bPressed) fHarmonics = fHarmonics - 1;
		if (GetKey(olc::N).bPressed) fHarmonics = fHarmonics + 1;
		if (fHarmonics < 1.0f) fHarmonics = 1.0f;
		*/

		int i, j;

		auto GetTile = [&](float x, float y) {
			int nx = x; //So dividing it by 16 actually seems to work.
			int ny = y;
			if (nx >= 0 && nx < nLevelWidth && ny >= 0 && ny < nLevelHeight) {
				//std::cout << TestMap[ny * nLevelWidth + nx];
				return CurrentMap[ny * nLevelWidth + nx];
			}
			else {
				return ' ';
			}
		};

		auto SetTile = [&](int x, int y, char c) {
			if (x >= 0 && x < nLevelWidth && y >= 0 && y < nLevelHeight) {
				CurrentMap[y * nLevelWidth + x] = c;
				//CurrentLevelMap.bbRows[y].cols[x] = c;
			}
		};


		//auto ShowActiveCell = [&]() {
		//	olc::vi2d ActiveCell;
		//	ActiveCell = BrownWizard.pos / 16;
		//	SetTile(ActiveCell.x, ActiveCell.y, 'F');
		//	std::cout << "ActiveCell  :" << ActiveCell.x << " , " << ActiveCell.y << std::endl;
		//	std::cout << "TileOffset  :" << TileOffset.x << " , " << TileOffset.y << std::endl;
		//};

		//Player Input
		if (InMenu == true) {
			if (InMainMenu == true) {
				DrawStringDecal({ 40, 10 }, "Tesla Tales", olc::Pixel(128, 64, 0), { 2,2 });
				DrawStringDecal({ 40, 30 }, "Space to select", olc::Pixel(128, 64, 0), { 1,1 });
				DrawStringDecal({ 40, 80 }, "Arrows to navigate", olc::Pixel(128, 64, 0), { 1,1 });
				DrawStringDecal({ 40, 230 }, "Click on screen to focus", olc::Pixel(128, 64, 0), { 1,1 });
				(nMenuSelect == 0) ? DrawStringDecal({ 40, 60 }, "Start Game", olc::YELLOW, { 2,2 }) : DrawStringDecal({ 40, 60 }, "Start Game", olc::Pixel(128, 64, 0), { 2,2 });
				(nMenuSelect == 1) ? DrawStringDecal({ 40, 110 }, "Instructions", olc::YELLOW, { 2,2 }) : DrawStringDecal({ 40, 110 }, "Instructions", olc::Pixel(128, 64, 0), { 2,2 });
				(nMenuSelect == 2) ? DrawStringDecal({ 40, 160 }, "Licence", olc::YELLOW, { 2,2 }) : DrawStringDecal({ 40, 160 }, "Licence", olc::Pixel(128, 64, 0), { 2,2 });
				(nMenuSelect == 3) ? DrawStringDecal({ 40, 210 }, "Credits", olc::YELLOW, { 2,2 }) : DrawStringDecal({ 40, 210 }, "Credits", olc::Pixel(128, 64, 0), { 2,2 });
				if (GetKey(olc::DOWN).bPressed) (nMenuSelect < 3) ? nMenuSelect++ : nMenuSelect = 0;
				if (GetKey(olc::UP).bPressed) (nMenuSelect > 0) ? nMenuSelect-- : nMenuSelect = 3;
				if (GetKey(olc::SPACE).bPressed) InMainMenu = false;
			} else {
				switch (nMenuSelect) {
				case 0:
					InMenu = false;
					break;
				case 1:
					DrawStringDecal({ 40, 10 }, "Space to return to menu", olc::Pixel(128, 64, 0), { 1,1 });
					DrawStringDecal({ 40, 40 }, "A - LEFT", olc::Pixel(128, 64, 0), { 1.5,1.5 });
					DrawStringDecal({ 40, 80 }, "D - RIGHT", olc::Pixel(128, 64, 0), { 1.5,1.5});
					DrawStringDecal({ 40, 120 }, "W - PICK UP/DROP", olc::Pixel(128, 64, 0), { 1.5,1.5 });
					DrawStringDecal({ 40, 160 }, "RETURN - JUMP", olc::Pixel(128, 64, 0), { 1.5,1.5 });
					DrawStringDecal({ 40, 200 }, "SPACE - NEXT LIFE", olc::Pixel(128, 64, 0), { 1.5,1.5 });
					DrawStringDecal({ 40, 225 }, "Hint: There is no double jump", olc::Pixel(128, 64, 0), { 0.8,0.8 });
					DrawStringDecal({ 40, 235 }, "but you can jump from falling", olc::Pixel(128, 64, 0), { 0.8,0.8 });
					break;
				case 2:
					Licence.clear();
					Licence.push_back("Tesla Tales Demo - Based on a One Lone Coder kernel.");
					Licence.push_back("");
					Licence.push_back("");
					Licence.push_back("License(OLC - 3) ~~~~~~~~~~~~~~~");
					Licence.push_back("");
					Licence.push_back("Copyright 2018 - 2020 OneLoneCoder.com");
					Licence.push_back("");
					Licence.push_back("redistribution and use in source and binary forms, with or without modification,");
					Licence.push_back("are permitted provided that the following conditions are met :");
					Licence.push_back("");
					Licence.push_back("1. Redistributions or derivations of source code must retain the above copyright");
					Licence.push_back("notice, this list of conditions and the following disclaimer.");
					Licence.push_back("");
					Licence.push_back("2. Redistributions or derivative works in binary form must reproduce the above");
					Licence.push_back("copyright notice.This list of conditions and the following	disclaimer must be");
					Licence.push_back("reproduced in the documentation and /or other materials provided with the distribution.");
					Licence.push_back("");
					Licence.push_back("3. Neither the name of the copyright holder nor the names of its contributors may");
					Licence.push_back("be used to endorse or promote products derived from this software without specific");
					Licence.push_back("prior written permission.");
					Licence.push_back("");
					Licence.push_back("THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS	'AS IS' AND ANY");
					Licence.push_back("EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES");
					Licence.push_back("OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.IN NO EVENT");
					Licence.push_back("SHALL THE COPYRIGHT	HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,");
					Licence.push_back("INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED");
					Licence.push_back("TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR");
					Licence.push_back("BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN");
					Licence.push_back("CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN");
					Licence.push_back("ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF");
					Licence.push_back("SUCH DAMAGE.");

					numLines = 1;

					for (std::string bbStr : Licence) { DrawStringDecal({ 0, (float) (20 + (7 * numLines)) }, bbStr, olc::Pixel(128, 64, 0), { 0.3,0.3 }); numLines++; }
					break;
				case 3:
					DrawStringDecal({ 40, 50 }, "Tesla Tales is written in the Pixel Game Engine", olc::Pixel(128, 64, 0), { 0.5,0.5 });
					DrawStringDecal({ 40, 60 }, "which is the work of One Lone Conder David Barr.", olc::Pixel(128, 64, 0), { 0.5,0.5 });
					DrawStringDecal({ 40, 70 }, "Concept and coding Benedict Brown.", olc::Pixel(128, 64, 0), { 0.5,0.5 });
					break;
				}
				if (GetKey(olc::SPACE).bPressed) InMainMenu = true;
			}
			//if (GetKey(olc::SPACE).bPressed) InMenu = false;

		}
		else {
			if (InCutScene == false) {
				if (BrownWizard.bDead == false && bDemoFinished == false) {
					if (BrownWizard.bJumping == false) {
						//if (GetKey(olc::ENTER).bPressed) { if (BrownWizard.StaffEnergised == true) { BrownWizard.vel.y = -120; } else { BrownWizard.vel.y = -100; }; BrownWizard.bJumping = true; };
						if (GetKey(olc::ENTER).bPressed) { BrownWizard.vel.y = -100; BrownWizard.bJumping = true; };
					}
					if (GetKey(olc::A).bHeld) { BrownWizard.vel.x -= 12 / 4; if (BrownWizard.vel.x < -20)  BrownWizard.vel.x = -20; BrownWizard.bMovingLeft = true; BrownWizard.bMovingRight = false; }
					if (GetKey(olc::D).bHeld) { BrownWizard.vel.x += 12 / 4; if (BrownWizard.vel.x > 20)  BrownWizard.vel.x = 20; BrownWizard.bMovingRight = true; BrownWizard.bMovingLeft = false; }
					if (GetKey(olc::BACK).bPressed) { BrownWizard.vel.y = -100; };
					if (GetKey(olc::W).bPressed) { ActivatePressed(); };
				}

				if (GetKey(olc::SPACE).bPressed) {
					if (bDemoFinished == true) { bDemoFinished = false; BrownWizard.bDead = false; LoadCurrentLevel(nCurrentLevel, true);
					} else {
						if (BrownWizard.Lives > 0) { if (BrownWizard.bDead == true) { ReturningToLife(); BrownWizard.bDead = false; BrownWizard.Lives--; } 
						} else { if (BrownWizard.bDead == true) { BrownWizard.bDead = false; LoadCurrentLevel(nCurrentLevel, true); } }
					}
				} //bKillerBlow = false; }


				if (GetKey(olc::I).bPressed) {
					//std::cout << "TileOffset.x: " << TileOffset.x; std::cout << " BrownWIzard.pos.x:" << BrownWizard.pos.x << std::endl;
					//std::cout << "Current clock" << BrownWizard.MovementClock << std::endl;
					bbEventHandler(1);
				}

				BrownWizard.vel.y += 80 * fElapsedTime;
				if (BrownWizard.bJumping == false) {
					if (BrownWizard.vel.x > 0) { BrownWizard.vel.x -= 20 * fElapsedTime; }
					if (BrownWizard.vel.x < 0) { BrownWizard.vel.x += 20 * fElapsedTime; }
					if (abs(BrownWizard.vel.x) < 1) { BrownWizard.vel.x = 0; }
				}
				BrownWizard.MovementClock += fElapsedTime;
				if (BrownWizard.MovementClock > 0.5) { BrownWizard.MovementClock = 0; BrownWizard.AnimationSate = (BrownWizard.AnimationSate++ % 2); }
				//std::cout << "AnimationState: " << BrownWizard.AnimationSate << " ";

				//if (GetKey(olc::F).bPressed) ShowActiveCell();
				BrownWizard.newPos = BrownWizard.pos + BrownWizard.vel * fElapsedTime;


				//Collison Detection - scenery
				if (BrownWizard.vel.x <= 0) { //moving left
					if (GetTile(BrownWizard.newPos.x / 16 + 0.0f, BrownWizard.pos.y / 16 + 0.0f) != '.' || GetTile(BrownWizard.newPos.x / 16 + 0.0f, BrownWizard.pos.y / 16 + 0.99f) != '.') {
						BrownWizard.newPos.x = (int)BrownWizard.newPos.x + (16 - (int)BrownWizard.newPos.x % 16);
						BrownWizard.vel.x = 0;
					}
				}
				else { // moving right
					if (GetTile(BrownWizard.newPos.x / 16 + 0.99f, BrownWizard.pos.y / 16 + 0.0f) != '.' || GetTile(BrownWizard.newPos.x / 16 + 0.99f, BrownWizard.pos.y / 16 + 0.99f) != '.') {
						BrownWizard.newPos.x = (int)BrownWizard.newPos.x - (int)BrownWizard.newPos.x % 16;
						BrownWizard.vel.x = 0;
					}
				}
				if (BrownWizard.vel.y <= 0) { //moving up
					if (GetTile(BrownWizard.newPos.x / 16 + 0.0f, BrownWizard.newPos.y / 16) != '.' || GetTile(BrownWizard.newPos.x / 16 + 0.99f, BrownWizard.newPos.y / 16) != '.') {
						BrownWizard.newPos.y = (int)BrownWizard.newPos.y + (16 - (int)BrownWizard.newPos.y % 16);
						BrownWizard.vel.y = 0;
					}
				}
				else { // moving down
					if (GetTile(BrownWizard.newPos.x / 16 + 0.0f, BrownWizard.newPos.y / 16 + 0.99f) != '.' || GetTile(BrownWizard.newPos.x / 16 + 0.99f, BrownWizard.newPos.y / 16 + 0.99f) != '.') {
						BrownWizard.bJumping = false;
						if (((int)BrownWizard.newPos.y - (int)BrownWizard.newPos.y % 16) > 1) {
							BrownWizard.newPos.y = (int)BrownWizard.newPos.y - (int)BrownWizard.newPos.y % 16;
							BrownWizard.vel.y = 0;
						}
					}
				}

				BrownWizard.pos = BrownWizard.newPos;


				//Drawing Map

				if (abs(bbCamera.pos.x - BrownWizard.newPos.x) > 1)
					bbCamera.pos.x = BrownWizard.newPos.x;
				if (abs(bbCamera.pos.y - BrownWizard.newPos.y) > 1)
					bbCamera.pos.y = BrownWizard.newPos.y;

			}
			else { //Right plan is don't have any enemies where Wizard stops for Cut Scene. 
				CutScenePlayer(CutScenes[noCutScene]);
				bbCamera.pos += bbCamera.vel * fElapsedTime;
			}

			//Calculate Top-leftmost visible tile
			TileOffset.x = bbCamera.pos.x / 16 - nVisibleTilesX / 2.0f;
			TileOffset.y = bbCamera.pos.y / 16 - nVisibleTilesY / 2.0f;

			//Clamp Camera to game boundaries
			if (TileOffset.x < 0) TileOffset.x = 0;
			if (TileOffset.y < 0) TileOffset.y = 0;
			if (TileOffset.x > (nLevelWidth - nVisibleTilesX)) TileOffset.x = nLevelWidth - nVisibleTilesX;
			if (TileOffset.y > (nLevelHeight - nVisibleTilesY - 1)) TileOffset.y = nLevelHeight - nVisibleTilesY - 1;


			for (i = TileOffset.x; i <= TileOffset.x + nVisibleTilesX; i++) {
				for (j = TileOffset.y; j <= TileOffset.y + nVisibleTilesY; j++) {
					switch (CurrentMap[j * nLevelWidth + i]) {
					case '1'://Basic Block
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 16,16 }, { 16,16 }, olc::WHITE);
						break;
					case '2'://Place Holder
						break;
						//case 'T':
						//	DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 32,16 }, { 16,16 }, olc::WHITE);
						//	break;
					case 'Q'://Grey Backgound
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 0 * 16,2 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'q'://Zero
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 0 * 16,3 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'W'://Equals
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 1 * 16,2 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'w': //White
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 1 * 16,3 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'E': // Div E (We take it as this - we have two after all)
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 2 * 16,2 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'e': // Curl E (As above)
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 2 * 16,3 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'R': // Div E
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 3 * 16,2 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'r': // Curl E
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 3 * 16,3 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'T': // Div B (As above)
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 4 * 16,2 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 't': // Curl B (as above)
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 4 * 16,3 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'Y':// Div B
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 5 * 16,2 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'y':// Curl B
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 5 * 16,3 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'U': // Charge Density
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 6 * 16,2 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'u': // Permativity of Free Space
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 6 * 16,3 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'I': // Faraday Top Left
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 7 * 16,2 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'i': // Faraday Bottom  Left
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 7 * 16,3 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'O': // Faraday Top Right
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 8 * 16,2 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'o': // Faraday Bottom Right
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 8 * 16,3 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'P': //
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 9 * 16,2 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'p': // 
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 9 * 16,3 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'A':// Ampere 1,1
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 0 * 16,4 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'a':// Ampere 1,2
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 0 * 16,5 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'S':// Ampere 2,1
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 1 * 16,4 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 's':// Ampere 2,2
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 1 * 16,5 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'D': // Ampere 3,1
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 2 * 16,4 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'd': // Ampere 3,2
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 2 * 16,5 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'F': // Ampere 4,1
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 3 * 16,4 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'f': // Ampere 4,2
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 3 * 16,5 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'G': // 
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 4 * 16,4 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'g': // 
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 4 * 16,5 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'H': // 
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 0 * 16,2 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'J': // 
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 0 * 16,2 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'K': // 
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 0 * 16,2 * 16 }, { 16,16 }, olc::WHITE);
						break;
					case 'L': // 
						DrawPartialDecal({ (float)((i - TileOffset.x) * 16), (float)(-(TileOffset.y - j) * 16) }, { 16,16 }, decalTiles, { 0 * 16,2 * 16 }, { 16,16 }, olc::WHITE);
						break;
					}
				}
			}



			// Moving Enemies

			for (Enemy& E : Enemies)
				for (EnemySegment& S : E.Segments) {
					S.MovementClock += fElapsedTime;
					if (S.MovementClock > 0.1) { S.MovementClock = 0; S.AnimationState = (S.AnimationState++ % 2); }
				}

			for (Enemy& E : Enemies)
				for (EnemySegment& S : E.Segments) {
					S.pos += S.vel * fElapsedTime;
					if (S.pos.x <= E.LeftMostBound) {
						S.pos.x = E.LeftMostBound;
						S.vel.x = S.vel.x * -1;
					}
					if (S.pos.x >= E.RightMostBound) {
						S.pos.x = E.RightMostBound;
						S.vel.x = S.vel.x * -1;
					}
				}

			// Moving Dead Enemies
			for (Enemy& E : DeadEnemies)
				for (EnemySegment& S : E.Segments) {
					S.vel.y += 80 * fElapsedTime;
					S.pos += S.vel * fElapsedTime;
				}

			// Drawing KeyPoints
			for (KeyPoint KP : KeyPoints) {
				DrawPartialDecal({ KP.pos.x - (TileOffset.x * 16), KP.pos.y - (TileOffset.y * 16) }, { 32,16 }, decalTiles, { KP.HeldKey.patchpos.x * 16, KP.HeldKey.patchpos.y * 16 }, { 32,16 }, olc::WHITE);
			}

			// Drawing Correctly answered LockPoints - Remember we are moving them down a row.
			for (LockPoint LP : LockPoints) {
				if (LP.Open == true) { DrawPartialDecal({ LP.pos.x - (TileOffset.x * 16), LP.pos.y - ((TileOffset.y - 1) * 16) }, LP.AnswerPatchSize, decalTiles, LP.AnswerPatchPos * 16, LP.AnswerPatchSize, olc::WHITE); }
			}


			// Drawing Enemies

			// Test
			//DrawPartialDecal({ 200,200 }, { 16,16 }, decalEnemies, { 0,16 }, { 16,16 }, olc::WHITE);
			for (Enemy E : Enemies)
				for (EnemySegment S : E.Segments) {
					//std::cout << S.pos.x - BrownWizard.pos.x << " Cap'n" << std::endl;
					//std::cout << S.pos.y - BrownWizard.pos.y << " Cap'n" << std::endl;
					//std::cout << "Got here Cap'n" << std::endl;
					//std::cout << TileOffset.x  << ":" <<  TileOffset.y  << std::endl;
					//std::cout << S.patchpos.x << ":" << S.patchpos.y << std::endl;
					//We only want to draw Enemies that a close to the camera
					if (abs(S.pos.x - bbCamera.pos.x) < (17 * 16) && abs(S.pos.y - bbCamera.pos.y) < (17 * 16)) { //One extra for luck
						if (S.vel.x > 0) {
							if (S.AnimationState == 1) {
								DrawPartialDecal({ S.pos.x - (TileOffset.x * 16), S.pos.y - (TileOffset.y * 16) }, { 16,16 }, decalEnemies, { S.patchpos.x * 16, (S.patchpos.y + 2) * 16 }, { 16,16 }, olc::WHITE);
							}
							else {
								DrawPartialDecal({ S.pos.x - (TileOffset.x * 16), S.pos.y - (TileOffset.y * 16) }, { 16,16 }, decalEnemies, { S.patchpos.x * 16, (S.patchpos.y + 3) * 16 }, { 16,16 }, olc::WHITE);
							}
						}
						else {
							if (S.AnimationState == 1) {
								DrawPartialDecal({ S.pos.x - (TileOffset.x * 16), S.pos.y - (TileOffset.y * 16) }, { 16,16 }, decalEnemies, { S.patchpos.x * 16, S.patchpos.y * 16 }, { 16,16 }, olc::WHITE);
							}
							else {
								DrawPartialDecal({ S.pos.x - (TileOffset.x * 16), S.pos.y - (TileOffset.y * 16) }, { 16,16 }, decalEnemies, { S.patchpos.x * 16, (S.patchpos.y + 1) * 16 }, { 16,16 }, olc::WHITE);
							}
						}
					}
				}

			// Drawing Dead Enemies
			for (Enemy E : DeadEnemies)
				for (EnemySegment S : E.Segments) {
					DrawPartialDecal({ S.pos.x - (TileOffset.x * 16), S.pos.y - (TileOffset.y * 16) }, { 16,16 }, decalEnemies, { S.patchpos.x * 16, (S.patchpos.y + 2) * 16 }, { 16,16 }, olc::WHITE);
				}

			// Drawing Electricity - Cleopatra's Needle - Staff - Sphynx's eyes etc
			std::mt19937 gen1(rd1()); // seed the generator
			std::uniform_int_distribution<> distCN(0, 100);
			std::uniform_int_distribution<> distCNPatchx(0, 3);
			std::uniform_int_distribution<> distCNPatchy(0, 1);
			std::uniform_int_distribution<> distCNSS(80, 100);
			int CleopatrasNeedlePatchx = (int)distCNPatchx(gen1);
			int CleopatrasNeedlePatchy = (int)distCNPatchy(gen1);
			float CPNSizeScalar = (float)distCNSS(gen1) / 100;

			if (CleopatrasNeedleOn == true) {
				//std::cout << "In here Cap'n" << std::endl;
				//std::cout << (abs(bbCamera.pos.x - (89 * 16)) < 300) && (abs(bbCamera.pos.y - (528 - (24 * 16)) < 300));
				//std::cout << ":" << abs(bbCamera.pos.x - (89 * 64)) << std::endl;
				if ((abs(bbCamera.pos.x - 89 * 16) < 300) && (abs(bbCamera.pos.y - (528 - (24 * 16)) < 300))) {
					DrawPartialRotatedDecal({ 89 * 16 - TileOffset.x * 16 + 8, (528 - (24 * 16)) - TileOffset.y * 16 }, decalCleopatrasNeedle, CleopatrasNeedleTime += fElapsedTime * 5, { 24, 24 }, { (float)(CleopatrasNeedlePatchx * 3 * 16), (float)(CleopatrasNeedlePatchy * 3 * 16) }, { 3 * 16, 3 * 16 }, { CPNSizeScalar * 2, CPNSizeScalar * 2 }, olc::WHITE);
				}
			}

			//Drawing Wizard
			//DrawPartialRotatedDecal({ 100,100 }, decalWizard, 0, { 0,0 }, { 0,0 }, { 16,16 }, { 1,1 });
			if (BrownWizard.bDead == false) {
				if (BrownWizard.bJumping) {
					if (BrownWizard.vel.x > 0) { BrownWizard.bMovingRight = true; BrownWizard.bMovingLeft = false; }
					else {
						if (BrownWizard.vel.x < 0) { BrownWizard.bMovingLeft = true; BrownWizard.bMovingRight = false; }
						else {
							if (BrownWizard.vel.x == 0) { BrownWizard.bMovingLeft = false; BrownWizard.bMovingRight = false; }
						}
					}
					if (BrownWizard.bMovingRight)
						DrawPartialDecal({ BrownWizard.pos.x - (TileOffset.x * 16), BrownWizard.pos.y - (TileOffset.y * 16) }, { 16,16 }, decalWizard, { 0,16 }, { 16,16 }, olc::WHITE);
					if (BrownWizard.bMovingLeft)
						DrawPartialDecal({ BrownWizard.pos.x - (TileOffset.x * 16), BrownWizard.pos.y - (TileOffset.y * 16) }, { 16,16 }, decalWizard, { 48,16 }, { 16,16 }, olc::WHITE);
					if ((BrownWizard.bMovingLeft == false) && (BrownWizard.bMovingRight == false)) {
						DrawPartialDecal({ BrownWizard.pos.x - (TileOffset.x * 16), BrownWizard.pos.y - (TileOffset.y * 16) }, { 16,16 }, decalWizard, { 64,16 }, { 16,16 }, olc::WHITE);
					}
				}
				else {
					if (BrownWizard.vel.x > 0) { BrownWizard.bMovingRight = true; BrownWizard.bMovingLeft = false; }
					else {
						if (BrownWizard.vel.x < 0) { BrownWizard.bMovingLeft = true; BrownWizard.bMovingRight = false; }
						else {
							if (BrownWizard.vel.x == 0) { BrownWizard.bMovingLeft = false; BrownWizard.bMovingRight = false; }
						}
					}
					if (BrownWizard.bMovingRight) {
						if (BrownWizard.AnimationSate == 1)
							DrawPartialDecal({ BrownWizard.pos.x - (TileOffset.x * 16), BrownWizard.pos.y - (TileOffset.y * 16) }, { 16,16 }, decalWizard, { 16,0 }, { 16,16 }, olc::WHITE);
						if (BrownWizard.AnimationSate == 2)
							DrawPartialDecal({ BrownWizard.pos.x - (TileOffset.x * 16), BrownWizard.pos.y - (TileOffset.y * 16) }, { 16,16 }, decalWizard, { 0,0 }, { 16,16 }, olc::WHITE);
					}
					if (BrownWizard.bMovingLeft) {
						if (BrownWizard.AnimationSate == 1)
							DrawPartialDecal({ BrownWizard.pos.x - (TileOffset.x * 16), BrownWizard.pos.y - (TileOffset.y * 16) }, { 16,16 }, decalWizard, { 32,0 }, { 16,16 }, olc::WHITE);
						if (BrownWizard.AnimationSate == 2)
							DrawPartialDecal({ BrownWizard.pos.x - (TileOffset.x * 16), BrownWizard.pos.y - (TileOffset.y * 16) }, { 16,16 }, decalWizard, { 48,0 }, { 16,16 }, olc::WHITE);
					}
					if ((BrownWizard.bMovingLeft == false) && (BrownWizard.bMovingRight == false)) {
						DrawPartialDecal({ BrownWizard.pos.x - (TileOffset.x * 16), BrownWizard.pos.y - (TileOffset.y * 16) }, { 16,16 }, decalWizard, { 64,0 }, { 16,16 }, olc::WHITE);
					}
				}
			}
			else {
				DrawPartialDecal({ BrownWizard.pos.x - (TileOffset.x * 16), BrownWizard.pos.y - (TileOffset.y * 16) }, { 16,16 }, decalWizard, { 5 * 16 ,1 * 16 }, { 16,16 }, olc::WHITE);
			}
			//	DrawPartialSprite((fPlayerPosX - fOffsetX)* nTileWidth, (fPlayerPosY - fOffsetY)* nTileWidth, spriteMan, nDirModX* nTileWidth, nDirModY* nTileHeight, nTileWidth, nTileHeight);

			// Draw Energised Staff
			if (BrownWizard.StaffEnergised == true) {
				if (BrownWizard.bDead == false) {
					if (BrownWizard.bJumping) {
						if (BrownWizard.bMovingRight)
							DrawPartialRotatedDecal({ BrownWizard.pos.x - (TileOffset.x * 16) + 12, BrownWizard.pos.y - (TileOffset.y * 16) + 2 }, decalCleopatrasNeedle, CleopatrasNeedleTime += fElapsedTime * 5, { 24, 24 }, { (float)(CleopatrasNeedlePatchx * 3 * 16), (float)(CleopatrasNeedlePatchy * 3 * 16) }, { 3 * 16, 3 * 16 }, { CPNSizeScalar / 10, CPNSizeScalar / 10 }, olc::WHITE);
						if (BrownWizard.bMovingLeft)
							DrawPartialRotatedDecal({ BrownWizard.pos.x - (TileOffset.x * 16) + 3, BrownWizard.pos.y - (TileOffset.y * 16) + 2 }, decalCleopatrasNeedle, CleopatrasNeedleTime += fElapsedTime * 5, { 24, 24 }, { (float)(CleopatrasNeedlePatchx * 3 * 16), (float)(CleopatrasNeedlePatchy * 3 * 16) }, { 3 * 16, 3 * 16 }, { CPNSizeScalar / 10, CPNSizeScalar / 10 }, olc::WHITE);
						if ((BrownWizard.bMovingLeft == false) && (BrownWizard.bMovingRight == false)) {
							DrawPartialRotatedDecal({ BrownWizard.pos.x - (TileOffset.x * 16) + 8, BrownWizard.pos.y - (TileOffset.y * 16) + 2 }, decalCleopatrasNeedle, CleopatrasNeedleTime += fElapsedTime * 5, { 24, 24 }, { (float)(CleopatrasNeedlePatchx * 3 * 16), (float)(CleopatrasNeedlePatchy * 3 * 16) }, { 3 * 16, 3 * 16 }, { CPNSizeScalar / 10, CPNSizeScalar / 10 }, olc::WHITE);
						}
					}
					else {
						if (BrownWizard.bMovingRight) {
							if (BrownWizard.AnimationSate == 1)
								DrawPartialRotatedDecal({ BrownWizard.pos.x - (TileOffset.x * 16) + 12, BrownWizard.pos.y - (TileOffset.y * 16) + 2 }, decalCleopatrasNeedle, CleopatrasNeedleTime += fElapsedTime * 5, { 24, 24 }, { (float)(CleopatrasNeedlePatchx * 3 * 16), (float)(CleopatrasNeedlePatchy * 3 * 16) }, { 3 * 16, 3 * 16 }, { CPNSizeScalar / 10, CPNSizeScalar / 10 }, olc::WHITE);
							if (BrownWizard.AnimationSate == 2)
								DrawPartialRotatedDecal({ BrownWizard.pos.x - (TileOffset.x * 16) + 14, BrownWizard.pos.y - (TileOffset.y * 16) + 2 }, decalCleopatrasNeedle, CleopatrasNeedleTime += fElapsedTime * 5, { 24, 24 }, { (float)(CleopatrasNeedlePatchx * 3 * 16), (float)(CleopatrasNeedlePatchy * 3 * 16) }, { 3 * 16, 3 * 16 }, { CPNSizeScalar / 10, CPNSizeScalar / 10 }, olc::WHITE);
						}
						if (BrownWizard.bMovingLeft) {
							if (BrownWizard.AnimationSate == 1)
								DrawPartialRotatedDecal({ BrownWizard.pos.x - (TileOffset.x * 16) + 3, BrownWizard.pos.y - (TileOffset.y * 16) + 2 }, decalCleopatrasNeedle, CleopatrasNeedleTime += fElapsedTime * 5, { 24, 24 }, { (float)(CleopatrasNeedlePatchx * 3 * 16), (float)(CleopatrasNeedlePatchy * 3 * 16) }, { 3 * 16, 3 * 16 }, { CPNSizeScalar / 10, CPNSizeScalar / 10 }, olc::WHITE);
							if (BrownWizard.AnimationSate == 2)
								DrawPartialRotatedDecal({ BrownWizard.pos.x - (TileOffset.x * 16) + 1, BrownWizard.pos.y - (TileOffset.y * 16) + 2 }, decalCleopatrasNeedle, CleopatrasNeedleTime += fElapsedTime * 5, { 24, 24 }, { (float)(CleopatrasNeedlePatchx * 3 * 16), (float)(CleopatrasNeedlePatchy * 3 * 16) }, { 3 * 16, 3 * 16 }, { CPNSizeScalar / 10, CPNSizeScalar / 10 }, olc::WHITE);
						}
						if ((BrownWizard.bMovingLeft == false) && (BrownWizard.bMovingRight == false)) {
							DrawPartialRotatedDecal({ BrownWizard.pos.x - (TileOffset.x * 16) + 8, BrownWizard.pos.y - (TileOffset.y * 16) + 2 }, decalCleopatrasNeedle, CleopatrasNeedleTime += fElapsedTime * 5, { 24, 24 }, { (float)(CleopatrasNeedlePatchx * 3 * 16), (float)(CleopatrasNeedlePatchy * 3 * 16) }, { 3 * 16, 3 * 16 }, { CPNSizeScalar / 10, CPNSizeScalar / 10 }, olc::WHITE);
						}
					}
				}
				else {
					DrawPartialRotatedDecal({ BrownWizard.pos.x - (TileOffset.x * 16) + 8, BrownWizard.pos.y - (TileOffset.y * 16) + 13 }, decalCleopatrasNeedle, CleopatrasNeedleTime += fElapsedTime * 5, { 24, 24 }, { (float)(CleopatrasNeedlePatchx * 3 * 16), (float)(CleopatrasNeedlePatchy * 3 * 16) }, { 3 * 16, 3 * 16 }, { CPNSizeScalar / 10, CPNSizeScalar / 10 }, olc::WHITE);
				}
			}
			//DrawPartialRotatedDecal({ BrownWizard.pos.x - (TileOffset.x * 16) + 12, BrownWizard.pos.y - (TileOffset.y * 16) +2 }, decalCleopatrasNeedle, CleopatrasNeedleTime += fElapsedTime * 5, { 24, 24 }, { (float)(CleopatrasNeedlePatchx * 3 * 16), (float)(CleopatrasNeedlePatchy * 3 * 16) }, { 3 * 16, 3 * 16 }, { CPNSizeScalar /10, CPNSizeScalar/10 }, olc::WHITE);



			//Checking for Collisions
			for (Enemy& E : Enemies) {
				bCollisionOccurred = false;
				bool bKillerBlow = false;
				int CrazyCounter = 0;
				for (EnemySegment& S : E.Segments) {
					if (abs(S.pos.x - BrownWizard.pos.x) < 100 && abs(S.pos.y - BrownWizard.pos.y) < 100) {
						bool TopLeftInCollision = false;
						bool TopRightInCollision = false;
						bool BottomLeftInCollision = false;
						bool BottomRightInCollision = false;
						olc::aabb::rect  Srect;
						Srect.pos = S.pos;
						Srect.vel = S.vel;
						Srect.size = { 16,16 };
						olc::aabb::rect BrownWizardrect;
						BrownWizardrect.pos = BrownWizard.pos;
						BrownWizardrect.vel = BrownWizard.vel;
						BrownWizardrect.size = { 16, 16 };
						olc::vf2d ContactPoint;
						olc::vf2d ContactNormal;
						float t_hit_near;
						if (olc::aabb::RectVsRect(&Srect, &BrownWizardrect) == true) {
							bCollisionOccurred = true;
							//if (olc::aabb::RayVsRect(BrownWizard.pos, BrownWizard.vel / sqrt(BrownWizard.vel.x * BrownWizard.vel.x + BrownWizard.vel.y * BrownWizard.vel.y), &Srect, ContactPoint, ContactNormal, t_hit_near)) {
							//	DrawString({ 20,100 }, "In Collison Cap'n", olc::WHITE, 1);
							//	if (ContactNormal.y == -1) {
							//		std::cout << "We have a top hit Cap'n" << std::endl;
							//		if(BrownWizard.bDead != true) bKillerBlow = true;
							//	}
							//}
							// 
							// The first thing we want to do is find which corner/corners of the Wizard is most deeply in collision.
							TopLeftInCollision = olc::aabb::PointVsRect({ BrownWizard.pos.x, BrownWizard.pos.y }, &Srect);
							TopRightInCollision = olc::aabb::PointVsRect({ BrownWizard.pos.x + 16, BrownWizard.pos.y }, &Srect);
							BottomLeftInCollision = olc::aabb::PointVsRect({ BrownWizard.pos.x, BrownWizard.pos.y + 16 }, &Srect);
							BottomRightInCollision = olc::aabb::PointVsRect({ BrownWizard.pos.x + 16, BrownWizard.pos.y + 16 }, &Srect);
							//DrawString({ 20,150 }, std::to_string(ContactPoint.x) + ":" + std::to_string(ContactPoint.y), olc::WHITE, 1);
							//DrawString({ 20,170 }, std::to_string(ContactNormal.x) + ":" + std::to_string(ContactNormal.y), olc::WHITE, 1);
							//if (TopLeftInCollision == true) { BrownWizard.bDead = true; /*DrawStringDecal({0,20}, "Top Left", olc::WHITE, {1,1});*/ }
							//if (TopRightInCollision == true) { BrownWizard.bDead = true; /*DrawStringDecal({0,30}, "Top Right", olc::WHITE, {1,1}); */ }
							if (TopLeftInCollision == true || TopRightInCollision == true) {}
							else {
								// If both bottom left and bottom right are in collision we must have hit it smack on the top bKillerBlow!
								if (BottomLeftInCollision == true && BottomRightInCollision == true) {
									if (S.TopDeadly != true) {
										bKillerBlow = true; std::cout << "Killer Blow Dead On" << std::endl;
										goto KillerBlow;
									}
								}
								else {
									// A bottom left collision has to be a strike to the right of the chapper
									if (BottomLeftInCollision == true) { /*DrawStringDecal({0,40}, "Bottom Left", olc::WHITE, {1,1});*/
										if (((S.pos.x + 16) - BrownWizard.pos.x) >= (S.pos.y - (BrownWizard.pos.y + 16))) {
											if (S.TopDeadly != true) {
												bKillerBlow = true;
												std::cout << "Killer Blow Bottom Left" << std::endl;
												goto KillerBlow;
											}
										}
										else {
											//BrownWizard.bDead = true;
										}
									}

									// A bottom right collison has to be a strike to the left
									if (BottomRightInCollision == true) { /*DrawStringDecal({0,50}, "Bottom Right", olc::WHITE, {1,1});*/
										if (((BrownWizard.pos.x + 16) - S.pos.x) >= ((BrownWizard.pos.y + 16) - S.pos.y)) {
											if (S.TopDeadly != true) {
												bKillerBlow = true;
												std::cout << "Killer Blow Bottom Right" << std::endl;
												goto KillerBlow;
											}
										}
										else {
											//BrownWizard.bDead = true;
										}
									}
								}
							}
							//Lets apply some logic - as we are hoping to thump them from the top id TopLeft or TopRight are in Collison
							//Then we have certainly thumped them from the side so this is bunk and we are dead

						}
					}
					CrazyCounter++;
				}
				if (bCollisionOccurred == true) {
					BrownWizard.bDead = true; //std::cout << "Why am I here ?" << CrazyCounter << std::endl;
				}
				goto Skip;
			KillerBlow:
				if (BrownWizard.bDead != true) {
					BrownWizard.vel.y = -1 * BrownWizard.vel.y;
					DeadEnemies.push_back(E);
					ExplodeEnemy(DeadEnemies.back());
					for (EnemySegment& S : E.Segments) {
						S.pos.y = 2000; S.pos.x = 10000; bCollisionOccurred = false;
					}
				}
			Skip:
				;
				//if (bCollisionOccurred == true) {
				//	if (bKillerBlow == false) {
				//		BrownWizard.bDead = true; std::cout << "Why am I here ?" << CrazyCounter << std::endl;
				//	}
				//	else { for (EnemySegment& S : E.Segments) S.pos.y = 2000; }
				//}
			}

			//Tidy up OffScreen Enemies - Dead Enemies.
			if (Enemies.size() > 0) {
				auto i = remove_if(Enemies.begin(), Enemies.end(),
					[&](Enemy E) {return (E.Segments[0].pos.y > 1000);});
				if (i != Enemies.end()) {
					Enemies.erase(i, Enemies.end());
					std::cout << "Enemy erased Enemies" << std::endl;
				}
			}

			if (DeadEnemies.size() > 0) {
				auto i = remove_if(DeadEnemies.begin(), DeadEnemies.end(),
					[&](Enemy E) {return (E.Segments[0].pos.y > 1000);});
				if (i != DeadEnemies.end()) {
					DeadEnemies.erase(i, DeadEnemies.end());
					std::cout << "Enemy erased Dead Enemies" << std::endl;
				}
			}


			// Draw Info
			DrawPartialDecal({ 0, 5 }, { 16,16 }, decalWizard, { 16,0 }, { 16,16 }, olc::WHITE);
			DrawStringDecal({ 20, 8 }, "x" + std::to_string(BrownWizard.Lives), olc::YELLOW, { 1.8,1.8 });
			DrawPartialDecal({ 7 * 16, 5 }, { 32,16 }, decalTiles, { BrownWizard.HeldKey.patchpos.x * 16, BrownWizard.HeldKey.patchpos.y * 16 }, { 32,16 }, olc::WHITE);

			if (BrownWizard.Lives == 0 && BrownWizard.bDead) {
				DrawStringDecal({ 50, 40 }, "GAME", olc::WHITE, { 5,5 });DrawStringDecal({ 50, 144 }, "OVER", olc::WHITE, { 5,5 });
			}

			if (bDemoFinished == true) {
				DrawStringDecal({ 50, 40 }, "DEMO", olc::WHITE, { 5,5 });DrawStringDecal({ 50, 144 }, "OVER", olc::WHITE, { 5,5 });
			}
			//if (BrownWizard.bDead == false){
			//	DrawStringDecal({ 0,0 }, "He Lives", olc::WHITE, { 1,1 });
			//} else {
			//	DrawStringDecal({ 0,0 }, "He Falls", olc::WHITE, { 1,1 });
			//}
			//DrawStringDecal({ (float) 50, (float) 200 }, std::to_string(BrownWizard.pos.x) + ":" + std::to_string(BrownWizard.pos.y), olc::BLUE, { 1.0f,1.0f });
			//DrawString({ 100,100 }, "WTF", olc::WHITE, 3);
		}
		return true;
	}

	void ReturningToLife() {
		for(Enemy &E: Enemies)
			for (EnemySegment &S : E.Segments) {
				olc::aabb::rect  Srect;
				Srect.pos = S.pos;
				Srect.vel = S.vel;
				Srect.size = { 16,16 };
				olc::aabb::rect BrownWizardrect;
				BrownWizardrect.pos = BrownWizard.pos;
				BrownWizardrect.vel = BrownWizard.vel;
				BrownWizardrect.size = { 16, 16 };
				olc::vf2d ContactPoint;
				olc::vf2d ContactNormal;
				float t_hit_near;
				if (olc::aabb::RectVsRect(&Srect, &BrownWizardrect) == true) {
					DeadEnemies.push_back(E);
					ExplodeEnemy(DeadEnemies.back());
					for (EnemySegment& S : E.Segments) {
						S.pos.y = 2000; S.pos.x = 10000; bCollisionOccurred = false;
					}
				}
			}

	}

	void LoadCurrentLevel(int MapNo, bool bRestart) {

		if (bRestart == true) { BrownWizard.Lives = 3; } //Lets have our lives back
		BrownWizard.HeldKey = { 0, {0,8} };
		BrownWizard.StaffEnergised = false;
		Enemies.clear(); // Lets have a fresh set of Enemies
		DeadEnemies.clear();
		KeyPoints.clear();
		LockPoints.clear();

		switch (MapNo) {
		case 1:
			CurrentMap = Map1;
			BrownWizard.pos = { 0,528 };
			//BrownWizard.pos = { 145 * 16, 528 };
			break;
		case 2: 
			CurrentMap = Map2;
			BrownWizard.pos = { 0,0 };
			break;
		case 3:
			CurrentMap = Map3;
			BrownWizard.pos = { 0,0 };
			break;
		}

		int Counter = 0;
		for (char c : CurrentMap) {
			// '{' = Div E, '}' = Div B, '[' = Curl E, ']' = Curl B.
			//if (c != '2' && c != '3' && c != '4' && c != '5' && c != '6' && c != '7' &&
			//	c != '!' && c != '£' && c != '$' && c != '%' && c != '^' && c != '&' &&
			//	c != '{' && c != '}' && c != '[' && c != ']') {
				//CurrentLevelMap.bbRows[Counter / 256].cols[Counter % 256] = c;
			//} else {
				if (c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' ||
					c == '!' || c == '£' || c == '$' || c == '%' || c == '^' || c == '&') {
					//	std::cout << "WTF Cap'n" << std::endl;
					CurrentMap[Counter] = '.';
					LoadEnemy(c, Counter);
					//CurrentLevelMap.bbRows[Counter / 256].cols[Counter % 256] = '.';
				} else {
					if (c == '{' || c == '}' || c == '[' || c == ']') {
						CurrentMap[Counter] = '.';
						LoadKeyPoint(c, Counter);
					}
					else {
						if (c == 'E' || c == 'e' || c == 'T' || c == 't') {
							//Map does not need updating
							LoadLockPoint(c, Counter);
						}
						else {
							if (c == 'H' || c == 'J' || c == 'K' || c == 'L') {
								LoadLockPoint(c, Counter);
							}
						}
					}
				}
			//}
			Counter++;
		}
	}

	void LoadLevelAssets(char c) {

	}

	//void LoadKey(char c, int Counter) {
	//	Key NewKey;
	//	NewKey.
	//}


	void LoadKeyPoint(char c, int Counter) {
		Key NewKey;
		KeyPoint NewKeyPoint;
		NewKeyPoint.pos = { (float)(Counter % 256) * 16 , (float)(Counter / 256) * 16 };
		switch (c) {
		case '{':
			NewKey.Type = 1;
			NewKey.patchpos = {4,4};
			break;
		case '}':
			NewKey.Type = 2;
			NewKey.patchpos = {6,4};
			break;
		case '[':
			NewKey.Type = 3;
			NewKey.patchpos = {4,5};
			break;
		case ']':
			NewKey.Type = 4;
			NewKey.patchpos = {6,5};
			break;
		}
		NewKeyPoint.HeldKey = NewKey;
		KeyPoints.push_back(NewKeyPoint);
	}

	void LoadLockPoint(char c, int Counter) {
		LockPoint NewLockPoint;
		//LockPoint is actually in the row above
		NewLockPoint.pos = { (float)(Counter % 256) * 16 , (float)((Counter / 256) - 1) * 16 };
		switch (c) {
		case 'E':
			NewLockPoint.CorrectKey = { 1, {0,0} }; //Due to the method of drawing the answer patchpos redundant
			NewLockPoint.AnswerPatchPos = { 8, 0 };
			NewLockPoint.AnswerPatchSize = { 4 * 16, 2 * 16 };
			break;
		case 'e':
			NewLockPoint.CorrectKey = { 3, {0,0} };
			NewLockPoint.AnswerPatchPos = {7, 6};
			NewLockPoint.AnswerPatchSize = {5 * 16, 2 * 16}; 
			break;
		case 'T':
			NewLockPoint.CorrectKey = { 2, {0,0} };
			NewLockPoint.AnswerPatchPos = { 8, 4 };
			NewLockPoint.AnswerPatchSize = { 4 * 16, 1 * 16 };
			break;
		case 't':
			NewLockPoint.CorrectKey = { 4, {0,0} };
			NewLockPoint.AnswerPatchPos = {5, 8}; 
			NewLockPoint.AnswerPatchSize = { 7 * 16, 2 * 16 };
			break;
		case 'H':
			NewLockPoint.CorrectKey = { 1, {0,0} }; //Due to the method of drawing the answer patchpos redundant
			NewLockPoint.AnswerPatchPos = { 8, 0 };
			NewLockPoint.AnswerPatchSize = { 4 * 16, 2 * 16 };
			break;
		case 'J':
			NewLockPoint.CorrectKey = { 3, {0,0} };
			NewLockPoint.AnswerPatchPos = { 7, 6 };
			NewLockPoint.AnswerPatchSize = { 5 * 16, 2 * 16 };
			break;
		case 'K':
			NewLockPoint.CorrectKey = { 2, {0,0} };
			NewLockPoint.AnswerPatchPos = { 8, 4 };
			NewLockPoint.AnswerPatchSize = { 4 * 16, 1 * 16 };
			break;
		case 'L':
			NewLockPoint.CorrectKey = { 4, {0,0} };
			NewLockPoint.AnswerPatchPos = { 5, 8 };
			NewLockPoint.AnswerPatchSize = { 7 * 16, 2 * 16 };
			break;
		}
		LockPoints.push_back(NewLockPoint);
	}

	void ActivatePressed() {
		//Right this key is going to handle picking up keys and dropping keys
		//Lets do picking up keys first
		Key HoldKey;
		olc::aabb::rect BrownWizardrect;
		BrownWizardrect.pos = BrownWizard.pos;
		BrownWizardrect.vel = BrownWizard.vel;
		BrownWizardrect.size = { 16, 16 };
		int LockPointsOpened = 0; //Might as well keep it here - this is where we will be launching all cut scenes

		for (KeyPoint &KP : KeyPoints) {
			olc::aabb::rect  KPrect;
			KPrect.pos = KP.pos;
			KPrect.size = { 32,16 };
			if (olc::aabb::RectVsRect(&KPrect, &BrownWizardrect) == true) {
				HoldKey = KP.HeldKey;
				KP.HeldKey = BrownWizard.HeldKey;
				BrownWizard.HeldKey = HoldKey;
			}
		}

		//Now let's dig placing keys
		for (LockPoint& LP : LockPoints) {
			olc::aabb::rect LPrect;
			LPrect.pos = LP.pos;
			LPrect.size = { 32, 16 };
			if (olc::aabb::RectVsRect(&LPrect, &BrownWizardrect) == true) {
				std::cout << "Wizard Key :" << BrownWizard.HeldKey.Type << " Lock Key:" << LP.CorrectKey.Type << std::endl;
				if (BrownWizard.HeldKey.Type != 0) {
					if (BrownWizard.HeldKey.Type == LP.CorrectKey.Type) {
						BrownWizard.HeldKey = { 0, {0,8} }; //Give him back no key
						LP.Open = true;
					}
					else {
						if (LP.Open == false) { BrownWizard.bDead = true; }
					}
				}
			}
		} 

		// Lets count how many LockPoints are open
		for (LockPoint LP: LockPoints )
			if (LP.Open == true) { LockPointsOpened++; }

		//Now let's check to see if we need a cut scene or we have finished to level/demo
		switch (nCurrentLevel) {
		case 1:
			if (CutScenes[0].bPlayed == false) { if (LockPointsOpened == 4) { InCutScene = true; noCutScene = 0; } }
			if (LockPointsOpened == 8) { bDemoFinished = true; }
			break;
		case 2:
			break;
		case 3:
			break;
		}
	}

	void LoadEnemy(char c, int Counter) {
		float EnemyVel = -20;
		Enemy NewEnemy;
		EnemySegment Head;
		EnemySegment Body;
		EnemySegment Tail;
		switch (c) {
		case '2':
			std::cout << "Got here Cap'n" << std::endl;
			Head.pos = { (float) (Counter % 256) * 16 , (float) (Counter / 256) * 16 };
			NewEnemy.LeftMostBound = Head.pos.x - FindLeftmostBound(Counter) * 16;
			Head.vel.x = EnemyVel;
			std::cout << Head.pos.x << ":" << Head.pos.y << std::endl;
			Head.patchpos = { 0,0 };
			Head.TopDeadly = false;
			Body.pos = { (float) ((Counter + 1) % 256) * 16, (float) ((Counter + 1) / 256) * 16 };
			Body.vel.x = EnemyVel;
			Body.patchpos = { 1,0 };
			Body.TopDeadly = false;
			Tail.pos = { (float) ((Counter + 2) % 256) * 16, (float) ((Counter + 2) / 256) * 16 };
			NewEnemy.RightMostBound = Tail.pos.x + FindRightmostBound(Counter+2) * 16;
			std::cout << NewEnemy.LeftMostBound << ":" << Head.pos.x << ":" << NewEnemy.RightMostBound << " Cap'n" << std::endl;
			Tail.vel.x = EnemyVel;
			Tail.patchpos = { 2,0 };
			Tail.TopDeadly = false;
			NewEnemy.Segments.push_back(Tail);
			NewEnemy.Segments.push_back(Body);
			NewEnemy.Segments.push_back(Head);
			Enemies.push_back(NewEnemy);
			break;
		case '3':
			//std::cout << "Got here Cap'n" << std::endl;
			Head.pos = { (float)(Counter % 256) * 16 , (float)(Counter / 256) * 16 };
			NewEnemy.LeftMostBound = Head.pos.x - FindLeftmostBound(Counter) * 16;
			Head.vel.x = EnemyVel;
			std::cout << Head.pos.x << ":" << Head.pos.y << std::endl;
			Head.patchpos = { 3,0 };
			Head.TopDeadly = false;
			Body.pos = { (float)((Counter + 1) % 256) * 16, (float)((Counter + 1) / 256) * 16 };
			Body.vel.x = EnemyVel;
			Body.patchpos = { 4,0 };
			Body.TopDeadly = true;
			Tail.pos = { (float)((Counter + 2) % 256) * 16, (float)((Counter + 2) / 256) * 16 };
			NewEnemy.RightMostBound = Tail.pos.x + FindRightmostBound(Counter + 2) * 16;
			Tail.vel.x = EnemyVel;
			Tail.patchpos = { 5,0 };
			Tail.TopDeadly = true;
			NewEnemy.Segments.push_back(Tail);
			NewEnemy.Segments.push_back(Body);
			NewEnemy.Segments.push_back(Head);
			Enemies.push_back(NewEnemy);
			break;
		case '4':
			//std::cout << "Got here Cap'n" << std::endl;
			Head.pos = { (float)(Counter % 256) * 16 , (float)(Counter / 256) * 16 };
			NewEnemy.LeftMostBound = Head.pos.x - FindLeftmostBound(Counter) * 16;
			Head.vel.x = EnemyVel;
			std::cout << Head.pos.x << ":" << Head.pos.y << std::endl;
			Head.patchpos = { 6,0 };
			Head.TopDeadly = true;
			Body.pos = { (float)((Counter + 1) % 256) * 16, (float)((Counter + 1) / 256) * 16 };
			NewEnemy.RightMostBound = Body.pos.x + FindRightmostBound(Counter + 1) * 16;
			Body.vel.x = EnemyVel;
			Body.patchpos = { 7,0 };
			Body.TopDeadly = false;
			NewEnemy.Segments.push_back(Body);
			NewEnemy.Segments.push_back(Head);
			Enemies.push_back(NewEnemy);
			break;
		case '5':
			//std::cout << "Got here Cap'n" << std::endl;
			Head.pos = { (float)(Counter % 256) * 16 , (float)(Counter / 256) * 16 };
			NewEnemy.LeftMostBound = Head.pos.x - FindLeftmostBound(Counter) * 16;
			Head.vel.x = EnemyVel;
			std::cout << Head.pos.x << ":" << Head.pos.y << std::endl;
			Head.patchpos = { 8,0 };
			Head.TopDeadly = true;
			Body.pos = { (float)((Counter + 1) % 256) * 16, (float)((Counter + 1) / 256) * 16 };
			NewEnemy.RightMostBound = Body.pos.x + FindRightmostBound(Counter + 1) * 16;
			Body.vel.x = EnemyVel;
			Body.patchpos = { 9,0 };
			Body.TopDeadly = true;
			NewEnemy.Segments.push_back(Body);
			NewEnemy.Segments.push_back(Head);
			Enemies.push_back(NewEnemy);
			break;
		case '6':
			//std::cout << "Got here Cap'n" << std::endl;
			Head.pos = { (float)(Counter % 256) * 16 , (float)(Counter / 256) * 16 };
			NewEnemy.LeftMostBound = Head.pos.x - FindLeftmostBound(Counter) * 16;
			NewEnemy.RightMostBound = Head.pos.x + FindRightmostBound(Counter) * 16;
			Head.vel.x = EnemyVel;
			std::cout << Head.pos.x << ":" << Head.pos.y << std::endl;
			Head.patchpos = { 10,0 };
			Head.TopDeadly = false;
			NewEnemy.Segments.push_back(Head);
			Enemies.push_back(NewEnemy);
			break;
		case '7':
			//std::cout << "Got here Cap'n" << std::endl;
			Head.pos = { (float)(Counter % 256) * 16 , (float)(Counter / 256) * 16 };
			Head.vel.x = EnemyVel;
			NewEnemy.LeftMostBound = Head.pos.x - FindLeftmostBound(Counter) * 16;
			NewEnemy.RightMostBound = Head.pos.x + FindRightmostBound(Counter) * 16;
			std::cout << Head.pos.x << ":" << Head.pos.y << std::endl;
			Head.patchpos = { 11,0 };
			Head.TopDeadly = true;
			NewEnemy.Segments.push_back(Head);
			Enemies.push_back(NewEnemy);
			break;
		case '!':
			//std::cout << "Got here Cap'n" << std::endl;
			Head.pos = { (float)(Counter % 256) * 16 , (float)(Counter / 256) * 16 };
			NewEnemy.RightMostBound = Head.pos.x + FindRightmostBound(Counter) * 16;
			Head.vel.x = -1 * EnemyVel;
			std::cout << Head.pos.x << ":" << Head.pos.y << std::endl;
			Head.patchpos = { 0,0 };
			Head.TopDeadly = false;
			Body.pos = { (float)((Counter - 1) % 256) * 16, (float)((Counter - 1) / 256) * 16 };
			Body.vel.x = -1 * EnemyVel;
			Body.patchpos = { 1,0 };
			Body.TopDeadly = false;
			Tail.pos = { (float)((Counter - 2) % 256) * 16, (float)((Counter - 2) / 256) * 16 };
			NewEnemy.LeftMostBound = Tail.pos.x - FindLeftmostBound(Counter - 2) * 16;
			Tail.vel.x = -1 * EnemyVel;
			Tail.patchpos = { 2,0 };
			Tail.TopDeadly = false;
			NewEnemy.Segments.push_back(Tail);
			NewEnemy.Segments.push_back(Body);
			NewEnemy.Segments.push_back(Head);
			Enemies.push_back(NewEnemy);
			break;
		case '£':
			//std::cout << "Got here Cap'n" << std::endl;
			Head.pos = { (float)(Counter % 256) * 16 , (float)(Counter / 256) * 16 };
			NewEnemy.RightMostBound = Head.pos.x + FindRightmostBound(Counter) * 16;
			Head.vel.x = -1 * EnemyVel;
			std::cout << Head.pos.x << ":" << Head.pos.y << std::endl;
			Head.patchpos = { 3,0 };
			Head.TopDeadly = false;
			Body.pos = { (float)((Counter - 1) % 256) * 16, (float)((Counter - 1) / 256) * 16 };
			Body.vel.x = -1 * EnemyVel;
			Body.patchpos = { 4,0 };
			Body.TopDeadly = true;
			Tail.pos = { (float)((Counter - 2) % 256) * 16, (float)((Counter - 2) / 256) * 16 };
			NewEnemy.LeftMostBound = Tail.pos.x - FindLeftmostBound(Counter - 2) * 16;
			Tail.vel.x = -1 * EnemyVel;
			Tail.patchpos = { 5,0 };
			Tail.TopDeadly = true;
			NewEnemy.Segments.push_back(Tail);
			NewEnemy.Segments.push_back(Body);
			NewEnemy.Segments.push_back(Head);
			Enemies.push_back(NewEnemy);
			break;
		case '$':
			//std::cout << "Got here Cap'n" << std::endl;
			Head.pos = { (float)(Counter % 256) * 16 , (float)(Counter / 256) * 16 };
			NewEnemy.RightMostBound = Head.pos.x + FindRightmostBound(Counter) * 16;
			Head.vel.x = -1 * EnemyVel;
			std::cout << Head.pos.x << ":" << Head.pos.y << std::endl;
			Head.patchpos = { 6,0 };
			Head.TopDeadly = true;
			Body.pos = { (float)((Counter - 1) % 256) * 16, (float)((Counter - 1) / 256) * 16 };
			NewEnemy.LeftMostBound = Body.pos.x - FindLeftmostBound(Counter - 1) * 16;
			Body.vel.x = -1 * EnemyVel;
			Body.patchpos = { 7,0 };
			Body.TopDeadly = false;
			NewEnemy.Segments.push_back(Body);
			NewEnemy.Segments.push_back(Head);
			Enemies.push_back(NewEnemy);
			break;
		case '%':
			//std::cout << "Got here Cap'n" << std::endl;
			Head.pos = { (float)(Counter % 256) * 16 , (float)(Counter / 256) * 16 };
			NewEnemy.RightMostBound = Head.pos.x + FindRightmostBound(Counter) * 16;
			Head.vel.x = -1 * EnemyVel;
			std::cout << Head.pos.x << ":" << Head.pos.y << std::endl;
			Head.patchpos = { 8,0 };
			Head.TopDeadly = true;
			Body.pos = { (float)((Counter - 1) % 256) * 16, (float)((Counter - 1) / 256) * 16 };
			NewEnemy.LeftMostBound = Body.pos.x - FindLeftmostBound(Counter - 1) * 16;
			Body.vel.x = -1 * EnemyVel;
			Body.patchpos = { 9,0 };
			Body.TopDeadly = true;
			NewEnemy.Segments.push_back(Body);
			NewEnemy.Segments.push_back(Head);
			Enemies.push_back(NewEnemy);
			break;
		case '^':
			//std::cout << "Got here Cap'n" << std::endl;
			Head.pos = { (float)(Counter % 256) * 16 , (float)(Counter / 256) * 16 };
			NewEnemy.RightMostBound = Head.pos.x + FindRightmostBound(Counter) * 16;
			NewEnemy.LeftMostBound = Head.pos.x - FindLeftmostBound(Counter) * 16;
			Head.vel.x = -1 * EnemyVel;
			std::cout << Head.pos.x << ":" << Head.pos.y << std::endl;
			Head.patchpos = { 10,0 };
			Head.TopDeadly = false;
			NewEnemy.Segments.push_back(Head);
			Enemies.push_back(NewEnemy);
			break;
		case '&':
			//std::cout << "Got here Cap'n" << std::endl;
			Head.pos = { (float)(Counter % 256) * 16 , (float)(Counter / 256) * 16 };
			NewEnemy.RightMostBound = Head.pos.x + FindRightmostBound(Counter) * 16;
			NewEnemy.LeftMostBound = Head.pos.x - FindLeftmostBound(Counter) * 16;
			Head.vel.x = -1 * EnemyVel;
			std::cout << Head.pos.x << ":" << Head.pos.y << std::endl;
			Head.patchpos = { 11,0 };
			Head.TopDeadly = true;
			NewEnemy.Segments.push_back(Head);
			Enemies.push_back(NewEnemy);
			break;
		}
	}

	int FindLeftmostBound(int Counter) {
		//We are going to have a maximum movement of 5 
		int i;
		for (i = 0; i < 5; i++) {
			if (CurrentMap[Counter - i] != '.' || CurrentMap[Counter + 256 - i] == '.') {
				std::cout << "Got here Cap'n FLMB: " <<  i << std::endl;
				return i - 1;		
			}
		}
		return 3;

	}

	int FindRightmostBound(int Counter) {
		int i;
		for(i = 0; i < 5; i++)
			if (CurrentMap[Counter + i] != '.' || CurrentMap[Counter + 256 + i] == '.') {
				std::cout << "Got here Cap'n FRMB: " << i << std::endl;
				return i-1;
			}
		return 3;
	}

	void ExplodeEnemy(Enemy& E) {
		std::random_device rd; // obtain a random number from hardware
		std::mt19937 gen(rd()); // seed the generator
		std::uniform_int_distribution<> distr(-60, 60); // define the range
		for (EnemySegment &S : E.Segments) {
			S.vel.x = (float)distr(gen);
			S.vel.y = (float)distr(gen); 
		}
	}

	
	void CutScenePlayer(CutScene& CS) {
		//std::cout << CS.CurrentStep;
		if (CS.CurrentStep == 0) { bbCamera.pos = CS.CameraMovements[0].inipos; bbCamera.vel = CS.CameraMovements[0].vel; CS.CurrentStep++; }
		// Right we are either moving left or right, up or down... we have decided this - not both at once

		CS.Time += GetElapsedTime();

		if (CS.Time > CS.CameraMovements[CS.CurrentStep - 1].EndPause) {
			CS.Time = 0;
			if (CS.CurrentStep <= CS.TotalSteps) {
				bbEventHandler(CS.CameraMovements[CS.CurrentStep - 1].Event);
			}
			if (abs(bbCamera.vel.x) > 0) { // Moving Horizontally
				if (bbCamera.vel.x > 0) { // Moving Right
					if (bbCamera.pos.x >= CS.CameraMovements[CS.CurrentStep - 1].finalpos.x) {
						if (CS.CurrentStep < CS.TotalSteps) {
							bbCamera.pos = CS.CameraMovements[CS.CurrentStep].inipos;
							bbCamera.vel = CS.CameraMovements[CS.CurrentStep].vel;
						}
						CS.CurrentStep++;
						if (CS.CurrentStep == CS.TotalSteps +1) {
							InCutScene = false; CS.bPlayed = true;
						}
					}
					//std::cout << bbCamera.vel.x << ":" << bbCamera.vel.y << std::endl;
				}
				else { // Moving Left
					if (bbCamera.pos.x <= CS.CameraMovements[CS.CurrentStep - 1].finalpos.x) {
						if (CS.CurrentStep < CS.TotalSteps) {
							bbCamera.pos = CS.CameraMovements[CS.CurrentStep].inipos;
							bbCamera.vel = CS.CameraMovements[CS.CurrentStep].vel;
						}
						CS.CurrentStep++;
						if (CS.CurrentStep == CS.TotalSteps +1) {
							InCutScene = false; CS.bPlayed = true;
						}
					}
				}
			}
			else { // Moving Vertically
				if (bbCamera.vel.y > 0) { // Moving Down
					if (bbCamera.pos.y >= CS.CameraMovements[CS.CurrentStep - 1].finalpos.y) { 
						if (CS.CurrentStep < CS.TotalSteps) {
							bbCamera.pos = CS.CameraMovements[CS.CurrentStep].inipos;
							bbCamera.vel = CS.CameraMovements[CS.CurrentStep].vel;
						}
						CS.CurrentStep++;
						if (CS.CurrentStep == CS.TotalSteps +1) {
							InCutScene = false; CS.bPlayed = true;
						}
					}
				}
				else { // Moving Up - or stationary
				 //std::cout << "Moving Up";
					if (bbCamera.pos.y <= CS.CameraMovements[CS.CurrentStep - 1].finalpos.y) {
						if (CS.CurrentStep < CS.TotalSteps) {
							bbCamera.pos = CS.CameraMovements[CS.CurrentStep].inipos;
							bbCamera.vel = CS.CameraMovements[CS.CurrentStep].vel;
						}
						CS.CurrentStep++;
						if (CS.CurrentStep == CS.TotalSteps +1) {
							InCutScene = false; CS.bPlayed = true;
						}
					}
				}
			}
			
			std::cout << "Cut Scene TotalSteps:" << CS.TotalSteps << " CurrentStep:" << CS.CurrentStep << std::endl;
 		}
	}
	

	

	void bbEventHandler(int bbEvent) {
		switch (bbEvent) {
		case 0:
			//do nothing
			break;
		case 1:
			//Turn on Cleopatra's needle
			CleopatrasNeedleOn = true;
			BrownWizard.StaffEnergised = true;
			//Open path
			CurrentMap[28 * nLevelWidth + (106 - 18)] = '.';
			CurrentMap[28 * nLevelWidth + (107 - 18)] = '.';
			CurrentMap[28 * nLevelWidth + (108 - 18)] = '.';
			std::cout << "Switched on Cap'n." << std::endl;
			break;
		}
	}

	void SpriteMaskingLoader(const olc::vi2d& pos, olc::Sprite* sprite, const olc::vi2d& sourcepos, const olc::vi2d& size, uint32_t scale, uint8_t flip)
	{
		SpriteMasking(pos.x, pos.y, sprite, sourcepos.x, sourcepos.y, size.x, size.y, scale, flip);
	}


	void SpriteMasking(int32_t x, int32_t y, olc::Sprite* sprite, int32_t ox, int32_t oy, int32_t w, int32_t h, uint32_t scale, uint8_t flip)
	{
		if (sprite == nullptr)
			return;

		int32_t fxs = 0, fxm = 1, fx = 0;
		int32_t fys = 0, fym = 1, fy = 0;
		if (flip & olc::Sprite::Flip::HORIZ) { fxs = w - 1; fxm = -1; }
		if (flip & olc::Sprite::Flip::VERT) { fys = h - 1; fym = -1; }

		fx = fxs;
		for (int32_t i = 0; i < w; i++, fx += fxm) {
			fy = fys;
			for (int32_t j = 0; j < h; j++, fy += fym)
				if (sprite->GetPixel(fx + ox, fy + oy).b == 255)
					sprite->SetPixel({ fx + ox, fy + oy }, olc::Pixel::MASK);

		}
		int c = 0;
		c++;
	}

};

//std::atomic<float> OneLoneCoder_Platformer::fFrequency = 440.0f;
//std::atomic<float> OneLoneCoder_Platformer::fDutyCycle = 0.5f;
//std::atomic<float> OneLoneCoder_Platformer::fHarmonics = 20;


int main()
{
	OneLoneCoder_Platformer game;
	if (game.Construct(16 * 16, 16 * 16, 4, 4))
		game.Start();
	return 0;
}
